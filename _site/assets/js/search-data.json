{
  "0": {
    "id": "0",
    "title": "",
    "content": "404 Page not found :( The requested page could not be found.",
    "url": "http://0.0.0.0:4000/404.html",
    "relUrl": "/404.html"
  },
  "1": {
    "id": "1",
    "title": "Developer Experience",
    "content": "Developer Experience API Model Design Endpoint Design API Versioning Document Error Responses Developer SDK Query Parameters Pagination Security API Model Design Consolidate the inventory model There are multiple definitions of the inventory model. This will most likely be confusing to developers. For example, the current model describing what is used with the warehouse inventory PATCH shows a model with different properties than that used by the inventory item. Reducing inventory model to a single model will give a clearer more consistent experience to developers using the API. This is particularly helpful if clients are expected to only access inventory with a specific warehouse. Use the endpoint description to communicate if specific properties are required for the operation. Model Properties Adding ISO standard timestamps for when resources were created and updated would be very helpful for developers. Adding created_at and updated_at to the resource models will help developers build richer user experiences in their fronted applications and assist in searching for relevant data in results such as executing client side logic to find all of the returned items that were created in the last day. Using strings instead of integers in your api model definition will give flexibility to migrate to a different id type in the future (uuid for example). The documentation seems a bit ambiguous as to which should be used because the path parameters are of type string and the model ids are integers. Similarly, using strings for Skus will yield greater flexibility. In both of these instances, the use of an integer for these types seems to be more for indicating uniqueness rather than mathematical meaning. Endpoint Design Model Properties Swagger for the endpoint definitions are not consistently documented. For example, the PATCH and POST operations for inventory by warehouse id have summaries but do not have descriptions. Consider adding descriptions for these endpoints with more detail and relevant information. Including descriptions of the returned resources, constraints on the operation like return limits, and even details about the physical objects that are a part of the operation, can all enhance the use of the api for clients. Suggested Additional Endpoints Adding thes additional endpoints should only be done where it fits the actual model. For example, adding full CRUD operations for the inventory resource may not be desired if the domain model expects inventory to always be used with a related warehouse. In this case, making developers to use a valid warehouse id when interacting with inventory items will enforce the constraint. Here are some endpoints that might be useful to consider: GET /warehouses/{warehouseId} POST /warehouses/{warehouseId} PATCH /warehouses/{warehouseId} DELETE /warehouses/{warehouseId} GET /warehouses/{warehouseId}/inventory/{inventoryId} GET /factories/{factoryId} POST /factories/{factoryId} PATCH /factories/{factoryId} DELETE /factories/{factoryId} GET /factories/{factoryId}/machines/{machineId} POST /factories/{factoryId}/machines PATCH /factories/{factoryId}/machines/{machineId} DELETE /factories/{factoryId}/machines/{machineId} Additionally, pay especially close attention to the desired domain model when considering these CRUD inventory CRUD machines API Versioning Making sure the api is versioned will greatly help developers by allowing them to choose when to upgrade their client applications. One approach is to use semantic versioning. When using semantic versioning, only use the major version number in the url because it will indicate when a breaking change is present. All other changes are non-breaking and really have no direct impact on the functionality from the client’s perspective. Document Error Responses Documenting what to expect when things go wrong is just as important as documenting intended usage of the API. Here’s a list of suggested status codes and what they mean in an API: 304 Not Modified - Used when HTTP caching headers are in play 400 Bad Request - The request is malformed, such as if the body does not parse 401 Unauthorized - When no or invalid authentication details are provided. Also useful to trigger an auth popup if the API is used from a browser 403 Forbidden - When authentication succeeded but authenticated user doesn’t have access to the resource 404 Not Found - When a non-existent resource is requested 405 Method Not Allowed - When an HTTP method is being requested that isn’t allowed for the authenticated user 410 Gone - Indicates that the resource at this end point is no longer available. Useful as a blanket response for old API versions 415 Unsupported Media Type - If incorrect content type was provided as part of the request 422 Unprocessable Entity - Used for validation errors 429 Too Many Requests - When a request is rejected due to rate limiting References: Status Code RFC REST Interpretation Developer SDK One of the advantages to defining an API using the OpenAPI specification (Swagger) is the tooling around generating SDK clients. This can be a powerful enablement for getting client ramped up and using the API in their prefered development language. Swagger UI is another great tool for visualizing and trying out an API. Tools like these depend on access to the swagger yaml file. Consider making this file available to your clients for read access so they can leverage the great ecosystem around Swagger. Swagger Editor Swagger UI Swagger Codegen Query Parameters Adding query parameters to the api would allow clients to query specifically for the resources they might be looking for. As an example, a client could look up all of the warehouses in a specific city, state, or country. There really should be careful planning before going forward with adding query parameters. When adding query parameters keep in mind the implications on the data store ensuring proper indexes are created. Planning for the types of operations is critical as well. For example, searching for inventory items created in the last 24 hours, or for all names that start with letter ‘A’. Depending on the domain’s data model, querying for a specific property may invoke long running queries. Additionally, there may not even be enough volume from clients to warrant the effort in adding the query parameter. Pagination Pagination will not only improve the developer experience but it will also help optimize database queries and response times by limiting the number of results returned at one time. Consider following the pattern of how the Github API and Zendesk API paginate their results. They are both examples of using Web Link. Allowing the API to create the pagination links helps the client to focus more on the actual process of pagination rather than on creating links with correct location in the data set. Security Web security standards would suggest the api should only respond to https requests. The api could forward http requests to https or outright reject the http request. Because the intended clients are internal and external, the api should implement some authentication and authorization method. One suggestion is the oAuth2 standard. The oAuth2 standard has a number of qualities that make it a good candidate for the api. The first is the use of Json Web Tokens (JWT). A client’s access to the api is carried with JWT not the use of sessions or cookies. Typically with oAuth2, an client application is registered with the oAuth provider. The oAuth provider will define what scopes are available to the client app. These scopes can map to resources and actions such as the ability to write inventory or the ability to just read the inventory. When a client app requests a new JWT, the request will include desired scopes. If the desired scopes are allowed, the client is granted a set tokens through one of the allowed flows. Thus enabling the ability to give internal clients access to different sets of endpoints than external clients. Some of the results of implementing oAuth2 is client authentication, finer grained access controls to endpoints, and improved identity management for the api. References oAuth 2 Standard Json Web Tokens",
    "url": "http://0.0.0.0:4000/developer-experience/",
    "relUrl": "/developer-experience/"
  },
  "2": {
    "id": "2",
    "title": "",
    "content": "Introduction",
    "url": "http://0.0.0.0:4000/",
    "relUrl": "/"
  },
  "3": {
    "id": "3",
    "title": "Next Steps",
    "content": "Next Steps Operational Concerns API as a Product Operational Concerns API Health The api should have a health check endpoint that an operations team (and clients) can use to determine if the api is generally responsive. The api should be considered generally healthy if it is meeting the criteria defined in Service Level Objectives (SLO). These are the internal objectives that define the health of the api. It can be as simple as “the average api response time over a 5 minute period should be no more than 10 seconds”. In this case the the objective is clearly defined such that a measurable indicator, a Service Level Indicator (SLI), is defined: average api response time over a 5 minute period”. Monitoring should then be configured to track the SLI. Ideally the reviewing the SLO is automated. Client Service Level Agreements (SLA) are defined with the SLO in mind. In this case an SLA could be something like “the average response time over a 5 minute period will be no more than 30 seconds”. The health check can then be used to indicate if the service is degraded or failure state. Example relationship of SLI, SLO, and SLA SLO - “the average api response time over a 5 minute period should be no more than 10 seconds” SLI - “the average api response time over a 5 minute period” SLA - “the average api response time over a 5 minute period should be no more than 30 seconds” Also consider adding a link the SLA or Terms of Service to the Swagger API documentation. Client Management Working with internal and external clients really makes client management critical. Good client management will keep the access and ability of internal clients different than external clients. Rate limiting ( definitely recomended for external clients) will help control resource consumption and utilization, however internal clients might be rate limited differently than internal clients. Another example is with managing the access secrets for client apps and the respective scopes they have permissions to utilize. These are going to operational concerns and should be considered before taking next steps. API as a Product Reducing Friction Reducing friction is just as important in using an API as it is in an online marketplace. The less difficult it is for customers to find and complete a purchase the more likely the sale will actually take place and result in a returning customer. In the case of the API, the customer is the developer using the API. This means friction can come in a number of forms. One type of friction is speed to making the first API call. The clear documentation and simple examples on common tasks will help developers grow comfortable with the API sooner. A second form of friction is hidden in the language used in the API. Drawing from Domain Driven Development (DDD) concepts, identifying ubiquitous or common language around how resources described will not only reduce friction for the developer but also with how the developer communicates with their organization. For example, do factory managers use the term machines or capital equipment? A lot of confustion can be avoidedwWhen a developer is discussing progress or asking questions with their organization, if the factory manager and the developer are using the same term and agree on its definition. As the planning for the api progresses consider using ubiquitous language in the api definitions. Build, Measure, Learn Minimize wasted work by taking a lean approach to developing the api as a product. Start with a hypothesis that describes the impact that a api feature or change will make on the key performance indicators or service level objectives. Develop the feature and roll it out to a subset of the user base and measure the results. If the results support the hypothesis then roll it out to the greater audience and collect additional feedback directly from those users. Repeating this process for each new feature or update for the api will not only keep the work on the api pushing indicators in the right direction, but will also help eliminate wasted time and effort by avoiding developing full fledged features before their impact is really known.",
    "url": "http://0.0.0.0:4000/next-steps/",
    "relUrl": "/next-steps/"
  },
  "4": {
    "id": "4",
    "title": "Resources",
    "content": "Resources Some of the links used throught the review Semantic Versioning JSON Schema Swagger Editor Swagger UI Swagger Codegen oAuth 2 Standard Json Web Tokens Rest Best Practices DDD Bounded Context DDD Ubiquitous Language",
    "url": "http://0.0.0.0:4000/resources/",
    "relUrl": "/resources/"
  },
  "5": {
    "id": "5",
    "title": "Rest Design",
    "content": "Rest Design Swagger Yaml Fixes Top Level Entities Inventory Patch and Deletes Status Codes Swagger Yaml Fixes The original swagger definition file had a few typos that were corrected to bring it back to conforming to proper swagger. Recommend using the swagger editor and swagger ui tools to validate that the swagger is proper. Top Level Entities The factory and warehouse entities are described as “top level”, so those were moved two top level entities instead of the original groupings which had them spread througout several top level entity definitions. Inventory Patch and Deletes The inventory PATCH verb uses a itemDelete boolean to delete inventory items. The DELETE verb should be used instead. When implementing, consider whether it is more suitable to express the endpoint as one or both of /inventory/{id} or /warehouse/warehouseId/inventory/inventoryId. The first should run delete an inventory item with id. The second, will remove an inventory item with inventoryId that is in the warehouse with id of warehouseId. If the concept of inventory is usually thought of with a warehouse, then it might be more suitable to use the second option since there is relationship enforcement of the inventory with the specific warehouse. The inventory PATCH should include the inventoryId of the inventory item that is being patched. Also, instead of the response for the patched resource returning an array, it should return the inventory item that was updated (same observation for the POST). Finally, there should be clarity added to exactly what is being deleted by the inventory DELETE. Is it the entire inventory for that item or is it just some quantity since there is a quantity property on the original item. Status Codes Proper usage of status codes adheres to rest conventions just as the appropriate usage of HTTP verbs like DELETE. Here are some of the status codes that were not aligned with rest conventions: 204 for Delete inventory In the original swagger definition, deletes were part of the patch and returned a 201. The 201 status code is for creates. Use a 204 status code to indicate successful completion of the request with no body to return. 200 for Patch inventory The PATCH method returns a 201 which should be used when a new resource is created. A PATCH should return status code 200.",
    "url": "http://0.0.0.0:4000/rest-design/",
    "relUrl": "/rest-design/"
  },
  "6": {
    "id": "6",
    "title": "Updated Vandalay API",
    "content": "",
    "url": "http://0.0.0.0:4000/vandalay-api-updated/",
    "relUrl": "/vandalay-api-updated/"
  },
  "7": {
    "id": "7",
    "title": "Vandalay API",
    "content": "",
    "url": "http://0.0.0.0:4000/vandalay-api/",
    "relUrl": "/vandalay-api/"
  }
  
}
